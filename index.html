<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자율주행 레이싱 (Autonomous Racing)</title>
    
    <!-- Tailwind CSS (스타일링) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (리액트 코어) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel (JSX 변환기) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: #f1f5f9; font-family: sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Icon Components (SVG) ---
        // Lucide 아이콘을 외부 의존성 없이 직접 SVG로 구현하여 깃허브 페이지 호환성 확보
        const Play = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
        );
        const Pause = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
        );
        const RotateCcw = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
        );
        const Plus = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        );
        const Trash2 = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
        );
        const Cpu = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line></svg>
        );
        const Activity = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
        );
        const Trophy = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M8 21h8m-4-9v9m-8-2.5a6 6 0 0 1 12 0v2.5"></path><path d="M16 3h-8"></path><path d="M7 3v7a5 5 0 0 0 10 0V3"></path><path d="M19 6h2a2 2 0 0 1 2 2v1a2 2 0 0 1-2 2h-2"></path><path d="M5 6H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h2"></path></svg>
        );
        const Hash = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></svg>
        );
        const Radar = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z"></path><path d="M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"></path><line x1="12" y1="2" x2="12" y2="4"></line><line x1="12" y1="20" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="6.34" y2="6.34"></line><line x1="17.66" y1="17.66" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="4" y2="12"></line><line x1="20" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="6.34" y2="17.66"></line><line x1="17.66" y1="6.34" x2="19.07" y2="4.93"></line></svg>
        );
        const Timer = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="10" y1="2" x2="14" y2="2"></line><line x1="12" y1="14" x2="15" y2="11"></line><circle cx="12" cy="14" r="8"></circle></svg>
        );
        const Flag = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line></svg>
        );
        const MapIcon = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line></svg>
        );


        // --- Constants & Config ---
        const TRACK_WIDTH = 800;
        const TRACK_HEIGHT = 600;
        const FPS = 60;
        const CAR_SIZE = { width: 24, height: 14 };
        const SENSOR_RANGE = 150;

        // Detection Radius Config
        const CHECKPOINT_RADIUS_START = 220; 
        const CHECKPOINT_RADIUS_NORMAL = 120;
        const TOTAL_LAPS = 3;

        // Car Physics
        const ACCELERATION = 0.2;
        const MAX_SPEED = 6;
        const FRICTION = 0.96;
        const TURN_SPEED = 0.08;

        // Sensor Labels for UI
        const SENSOR_LABELS = {
            0: '좌측 센서',
            1: '전방 좌측',
            2: '전방 센서',
            3: '전방 우측',
            4: '우측 센서'
        };

        // Initial Logic Blocks
        const INITIAL_BLOCKS = [
          { id: 1, sensor: 2, operator: '<', valueType: 'number', value: 80, action: 'BRAKE' },
          { id: 2, sensor: 0, operator: '<', valueType: 'number', value: 40, action: 'RIGHT' },
          { id: 3, sensor: 4, operator: '<', valueType: 'number', value: 40, action: 'LEFT' },
          { id: 4, sensor: 0, operator: '>', valueType: 'sensor', value: 4, action: 'RIGHT' },
          { id: 5, sensor: 4, operator: '>', valueType: 'sensor', value: 0, action: 'LEFT' },
          { id: 6, sensor: 2, operator: '>', valueType: 'number', value: 0, action: 'ACCEL' },
        ];

        // --- Track Layouts ---
        const TRACK_LAYOUTS = [
            {
                id: 'technical',
                name: '테크니컬 서킷 (기본)',
                points: [
                    // Start Line at middle of top straight
                    { x: 350, y: 100 }, 
                    { x: 500, y: 50 }, { x: 700, y: 100 },
                    { x: 750, y: 250 }, { x: 600, y: 350 }, { x: 700, y: 500 }, { x: 500, y: 550 },
                    { x: 300, y: 500 }, { x: 150, y: 450 }, { x: 50, y: 300 }, 
                    { x: 100, y: 100 },
                    { x: 200, y: 100 } // Loop closer
                ]
            },
            {
                id: 'oval',
                name: '스피드 오벌 (초급)',
                points: [
                    { x: 400, y: 100 },
                    { x: 650, y: 100 }, 
                    { x: 750, y: 300 }, 
                    { x: 650, y: 500 }, { x: 150, y: 500 }, 
                    { x: 50, y: 300 },
                    { x: 150, y: 100 }
                ]
            },
            {
                id: 'hardcore',
                name: '하드코어 8자 (상급)',
                points: [
                    { x: 400, y: 100 }, { x: 700, y: 100 },
                    { x: 700, y: 500 }, { x: 400, y: 300 }, // Cross point
                    { x: 100, y: 500 }, { x: 100, y: 300 },
                    { x: 100, y: 100 }
                ]
            }
        ];

        const App = () => {
          // --- State ---
          const canvasRef = useRef(null);
          const [isPlaying, setIsPlaying] = useState(false);
          const [blocks, setBlocks] = useState(INITIAL_BLOCKS);
          const [gameState, setGameState] = useState('idle');
          const [winner, setWinner] = useState(null);
          const [sensorReadings, setSensorReadings] = useState([0, 0, 0, 0, 0]);
          const [currentTrackIdx, setCurrentTrackIdx] = useState(0);
          
          // Time States
          const [currentTime, setCurrentTime] = useState(0); 
          const [userStats, setUserStats] = useState({ 
            laps: 0, 
            currentLapTime: 0, 
            lastLapTime: 0,
            totalTime: 0
          });

          // Mutable Game Objects
          const cars = useRef([]);
          const requestRef = useRef();
          const startTimeRef = useRef(0);

          // --- Helpers ---
          const dist = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

          const getCurrentTrackPoints = () => TRACK_LAYOUTS[currentTrackIdx].points;

          const getStartAngle = () => {
              const points = getCurrentTrackPoints();
              const p1 = points[0];
              const p2 = points[1];
              return Math.atan2(p2.y - p1.y, p2.x - p1.x);
          };

          const isOffTrack = (x, y) => {
            const points = getCurrentTrackPoints();
            let minDist = Infinity;
            for (let i = 0; i < points.length; i++) {
              const p1 = points[i];
              const p2 = points[(i + 1) % points.length];
              const d = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
              if (d < minDist) minDist = d;
            }
            return minDist > 58; 
          };

          const distToSegment = (x, y, x1, y1, x2, y2) => {
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            return dist(x, y, xx, yy);
          };

          const castRays = (car) => {
            const readings = [];
            const angles = [-60, -30, 0, 30, 60]; 
            
            angles.forEach(offset => {
              const rayAngle = car.angle + (offset * Math.PI / 180);
              let distance = 0;
              let step = 2;
              let maxDist = SENSOR_RANGE;
              let rx = car.x;
              let ry = car.y;

              while (distance < maxDist) {
                rx += Math.cos(rayAngle) * step;
                ry += Math.sin(rayAngle) * step;
                distance += step;
                if (isOffTrack(rx, ry)) break;
              }
              readings.push(Math.min(distance, maxDist));
            });
            return readings;
          };

          // --- Game Loop Logic ---

          const updateCarPhysics = (car, inputs, timestamp) => {
            if (car.finished) return;

            // Steering
            if (Math.abs(car.speed) > 0.5) {
                car.angle += inputs.steer * TURN_SPEED * (car.speed > 0 ? 1 : -1);
            }

            // Acceleration & Friction
            car.speed += inputs.throttle * ACCELERATION;
            car.speed *= FRICTION;

            if (car.speed > MAX_SPEED) car.speed = MAX_SPEED;
            if (car.speed < -MAX_SPEED / 2) car.speed = -MAX_SPEED / 2;

            car.x += Math.cos(car.angle) * car.speed;
            car.y += Math.sin(car.angle) * car.speed;

            if (isOffTrack(car.x, car.y)) {
                car.speed *= 0.5; 
            }

            // Checkpoint & Lap Logic
            const points = getCurrentTrackPoints();
            const nextCpIdx = (car.lastCP + 1) % points.length;
            const nextCp = points[nextCpIdx];
            
            const detectionRadius = nextCpIdx === 0 ? CHECKPOINT_RADIUS_START : CHECKPOINT_RADIUS_NORMAL;

            if (dist(car.x, car.y, nextCp.x, nextCp.y) < detectionRadius) {
                car.lastCP = nextCpIdx;
                
                if (nextCpIdx === 0) {
                    car.laps++;
                    const now = timestamp;
                    const lapTime = (now - car.lapStartTime) / 1000;
                    car.lastLapTime = lapTime;
                    car.lapStartTime = now; 

                    if (car.laps >= TOTAL_LAPS) {
                        car.finished = true;
                        car.finishTime = (now - startTimeRef.current) / 1000;
                        
                        if (!winner) {
                            setWinner(car.id);
                            setGameState('finished');
                            setIsPlaying(false);
                        }
                    }
                }
            }
          };

          const getAIInputs = (car) => {
            const points = getCurrentTrackPoints();
            const targetIdx = (car.lastCP + 1) % points.length;
            const target = points[targetIdx];
            const desiredAngle = Math.atan2(target.y - car.y, target.x - car.x);
            let diff = desiredAngle - car.angle;
            while (diff <= -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;

            let steer = 0;
            if (diff > 0.1) steer = 1;
            if (diff < -0.1) steer = -1;

            let throttle = 1;
            if (Math.abs(diff) > 0.5) throttle = 0.5;
            const variance = (parseInt(car.id.slice(-1)) || 0) * 0.05;

            return { steer, throttle: throttle - variance };
          };

          const getUserInputs = (car, currentReadings) => {
            let steer = 0;
            let throttle = 0;
            let turnLeft = false;
            let turnRight = false;
            let gas = false;
            let brake = false;

            blocks.forEach(block => {
                const leftValue = currentReadings[block.sensor];
                let rightValue = block.valueType === 'sensor' ? currentReadings[block.value] : block.value;
                let conditionMet = false;
                
                if (block.operator === '<') conditionMet = leftValue < rightValue;
                if (block.operator === '>') conditionMet = leftValue > rightValue;

                if (conditionMet) {
                    switch(block.action) {
                        case 'LEFT': turnLeft = true; break;
                        case 'RIGHT': turnRight = true; break;
                        case 'ACCEL': gas = true; break;
                        case 'BRAKE': brake = true; break;
                        default: break;
                    }
                }
            });

            if (turnLeft) steer -= 1;
            if (turnRight) steer += 1;
            if (gas) throttle += 1;
            if (brake) throttle -= 1;
            return { steer, throttle };
          };

          const update = (timestamp) => {
            if (gameState === 'finished') return;
            
            if (startTimeRef.current === 0) {
                startTimeRef.current = timestamp;
                cars.current.forEach(c => c.lapStartTime = timestamp);
            }

            const currentTotalTime = (timestamp - startTimeRef.current) / 1000;
            setCurrentTime(currentTotalTime);

            const userCar = cars.current[0];
            const readings = castRays(userCar);
            setSensorReadings(readings);
            const userInputs = getUserInputs(userCar, readings);
            updateCarPhysics(userCar, userInputs, timestamp);

            cars.current.slice(1).forEach(car => {
                const aiInputs = getAIInputs(car);
                updateCarPhysics(car, aiInputs, timestamp);
            });

            setUserStats({
                laps: userCar.laps,
                currentLapTime: (timestamp - userCar.lapStartTime) / 1000,
                lastLapTime: userCar.lastLapTime,
                totalTime: userCar.finished ? userCar.finishTime : currentTotalTime
            });

            draw();
            if (isPlaying) {
                requestRef.current = requestAnimationFrame(update);
            }
          };

          const draw = () => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const points = getCurrentTrackPoints();
            
            // Clear
            ctx.fillStyle = '#4ade80';
            ctx.fillRect(0, 0, TRACK_WIDTH, TRACK_HEIGHT);

            // Draw Track
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Border
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 110;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.stroke();

            // White Curb
            ctx.strokeStyle = '#f8fafc';
            ctx.lineWidth = 100;
            ctx.stroke();

            // Asphalt
            ctx.strokeStyle = '#334155'; 
            ctx.lineWidth = 90;
            ctx.stroke();

            // Center Line
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Start Line (Rotated based on track direction)
            const startAngle = getStartAngle();
            ctx.save();
            ctx.translate(points[0].x, points[0].y);
            ctx.rotate(startAngle); 
            
            // Draw Start Line (Checkered)
            ctx.fillStyle = '#fff';
            ctx.fillRect(-10, -80, 20, 160); 
            
            ctx.fillStyle = '#000';
            for(let i=0; i<8; i++) {
                for(let j=0; j<2; j++) {
                    if((i+j)%2===0) ctx.fillRect(-10 + j*10, -80 + i*20, 10, 20);
                }
            }
            ctx.restore();

            // Draw Cars
            cars.current.forEach(car => {
                ctx.save();
                ctx.translate(car.x, car.y);
                ctx.rotate(car.angle);

                ctx.fillStyle = car.color;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 5;
                ctx.fillRect(-CAR_SIZE.width/2, -CAR_SIZE.height/2, CAR_SIZE.width, CAR_SIZE.height);
                
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(2, -5, 6, 10);
                ctx.restore();

                if (!car.isAI) {
                    const readings = castRays(car);
                    const angles = [-60, -30, 0, 30, 60];
                    readings.forEach((r, i) => {
                       ctx.save();
                       ctx.translate(car.x, car.y);
                       ctx.rotate(car.angle + (angles[i] * Math.PI / 180));
                       const grad = ctx.createLinearGradient(0, 0, r, 0);
                       grad.addColorStop(0, 'rgba(255, 255, 0, 0.5)');
                       grad.addColorStop(1, 'rgba(255, 0, 0, 0.8)');
                       ctx.fillStyle = grad;
                       ctx.fillRect(0, -1, r, 2);
                       ctx.fillStyle = 'red';
                       ctx.beginPath();
                       ctx.arc(r, 0, 3, 0, Math.PI * 2);
                       ctx.fill();
                       ctx.restore();
                    });
                }
            });
          };

          useEffect(() => {
            if (isPlaying) {
              requestRef.current = requestAnimationFrame(update);
            } else {
              cancelAnimationFrame(requestRef.current);
              draw();
            }
            return () => cancelAnimationFrame(requestRef.current);
          }, [isPlaying, blocks, gameState]);

          // Handle Track Change
          useEffect(() => {
              resetGame();
          }, [currentTrackIdx]);

          useEffect(() => {
            resetGame();
          }, []);

          const togglePlay = () => {
            if (gameState === 'finished') resetGame();
            if (!isPlaying && startTimeRef.current === 0) {
                startTimeRef.current = performance.now();
                cars.current.forEach(c => c.lapStartTime = startTimeRef.current);
            } 
            setIsPlaying(!isPlaying);
          };

          const resetGame = () => {
            setIsPlaying(false);
            setGameState('idle');
            setWinner(null);
            startTimeRef.current = 0;
            setCurrentTime(0);
            setUserStats({ laps: 0, currentLapTime: 0, lastLapTime: 0, totalTime: 0 });

            // Initialize cars based on track start position
            const points = TRACK_LAYOUTS[currentTrackIdx].points;
            const startPoint = points[0];
            const startAngle = Math.atan2(points[1].y - points[0].y, points[1].x - points[0].x);
            
            // Perpendicular vector for offset
            const px = Math.cos(startAngle + Math.PI/2);
            const py = Math.sin(startAngle + Math.PI/2);
            
            // Direction vector for starting behind line
            const dx = Math.cos(startAngle);
            const dy = Math.sin(startAngle);

            // Spawn BEHIND the line (e.g., -40px)
            const spawnX = startPoint.x - dx * 40;
            const spawnY = startPoint.y - dy * 40;

            cars.current = [
                { id: 'user', x: spawnX + px * 20, y: spawnY + py * 20, angle: startAngle, speed: 0, color: '#3b82f6', isAI: false, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0 },
                { id: 'ai1', x: spawnX - px * 20, y: spawnY - py * 20, angle: startAngle, speed: 0, color: '#ef4444', isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0 },
                { id: 'ai2', x: spawnX - dx * 40 - px * 10, y: spawnY - dy * 40 + py * 10, angle: startAngle, speed: 0, color: '#f59e0b', isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0 },
                { id: 'ai3', x: spawnX - dx * 40 + px * 10, y: spawnY - dy * 40 - py * 10, angle: startAngle, speed: 0, color: '#8b5cf6', isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0 },
            ];
            draw();
          };

          const addBlock = () => {
            const newBlock = { id: Date.now(), sensor: 2, operator: '<', valueType: 'number', value: 50, action: 'BRAKE' };
            setBlocks([...blocks, newBlock]);
          };

          const updateBlock = (id, field, value) => {
            setBlocks(blocks.map(b => b.id === id ? { ...b, [field]: value } : b));
          };

          const removeBlock = (id) => {
            setBlocks(blocks.filter(b => b.id !== id));
          };

          const toggleValueType = (id) => {
            setBlocks(blocks.map(b => {
                if (b.id === id) {
                    const newType = b.valueType === 'number' ? 'sensor' : 'number';
                    const newValue = newType === 'number' ? 50 : 0; 
                    return { ...b, valueType: newType, value: newValue };
                }
                return b;
            }));
          };

          const fmtTime = (s) => s.toFixed(2) + 's';

          return (
            <div className="flex flex-col md:flex-row h-screen bg-slate-900 text-slate-100 overflow-hidden font-sans">
              
              {/* --- Sidebar: Coding Area --- */}
              <div className="w-full md:w-1/3 flex flex-col border-r border-slate-700 bg-slate-800 shadow-xl z-10">
                <div className="p-4 bg-slate-900 border-b border-slate-700 space-y-4">
                  <div className="flex justify-between items-center">
                    <h2 className="text-xl font-bold flex items-center gap-2 text-blue-400">
                        <Cpu size={24} /> 
                        로직 에디터
                    </h2>
                    <div className="flex gap-2">
                        <button onClick={resetGame} className="p-2 bg-slate-700 hover:bg-slate-600 rounded-lg transition" title="초기화">
                            <RotateCcw size={20} />
                        </button>
                        <button onClick={togglePlay} className={`p-2 rounded-lg transition flex items-center gap-2 font-bold px-4 ${isPlaying ? 'bg-yellow-600 hover:bg-yellow-500' : 'bg-green-600 hover:bg-green-500'}`}>
                            {isPlaying ? <Pause size={20} /> : <Play size={20} />}
                            {isPlaying ? '일시정지' : '시작'}
                        </button>
                    </div>
                  </div>
                  
                  <div className="flex items-center gap-2 bg-slate-800 p-2 rounded-lg border border-slate-700">
                    <MapIcon size={18} className="text-slate-400" />
                    <select 
                        className="bg-transparent text-sm w-full outline-none text-slate-200"
                        value={currentTrackIdx}
                        onChange={(e) => setCurrentTrackIdx(Number(e.target.value))}
                    >
                        {TRACK_LAYOUTS.map((track, idx) => (
                            <option key={track.id} value={idx}>{track.name}</option>
                        ))}
                    </select>
                  </div>
                </div>

                <div className="p-4 bg-slate-800/50 border-b border-slate-700">
                    <div className="flex items-center gap-2 mb-2 text-xs uppercase tracking-wider text-slate-400">
                        <Activity size={14} /> 실시간 센서 거리
                    </div>
                    <div className="grid grid-cols-5 gap-1 text-center">
                        {sensorReadings.map((val, idx) => {
                            const labels = ['좌측', '전방좌측', '전방', '전방우측', '우측'];
                            const color = val < 50 ? 'text-red-400' : 'text-green-400';
                            return (
                                <div key={idx} className="bg-slate-900 p-2 rounded border border-slate-700">
                                    <div className="text-[10px] text-slate-500">{labels[idx]}</div>
                                    <div className={`font-mono text-sm font-bold ${color}`}>{Math.round(val)}</div>
                                </div>
                            );
                        })}
                    </div>
                </div>

                <div className="flex-1 overflow-y-auto p-4 space-y-3">
                  {blocks.length === 0 && (
                    <div className="text-slate-500 text-center py-10 italic">로직 블록이 없습니다.</div>
                  )}
                  
                  {blocks.map((block) => (
                    <div key={block.id} className="bg-slate-700 p-3 rounded-lg border-l-4 border-blue-500 shadow-sm flex items-center gap-2 flex-wrap text-sm group">
                      <span className="font-bold text-blue-300">만약</span>
                      <select className="bg-slate-900 border border-slate-600 rounded px-2 py-1 text-slate-200 focus:border-blue-500 outline-none"
                        value={block.sensor} onChange={(e) => updateBlock(block.id, 'sensor', parseInt(e.target.value))}>
                        {Object.entries(SENSOR_LABELS).map(([k, v]) => (<option key={k} value={k}>{v}</option>))}
                      </select>
                      <span>값이</span>
                      <select className="bg-slate-900 border border-slate-600 rounded px-2 py-1 text-slate-200 focus:border-blue-500 outline-none"
                        value={block.operator} onChange={(e) => updateBlock(block.id, 'operator', e.target.value)}>
                        <option value="<">작다면 (&lt;)</option>
                        <option value=">">크다면 (&gt;)</option>
                      </select>
                      <button onClick={() => toggleValueType(block.id)}
                        className="p-1 rounded bg-slate-600 hover:bg-slate-500 text-slate-200 transition"
                        title={block.valueType === 'number' ? "숫자와 비교하기" : "다른 센서와 비교하기"}>
                        {block.valueType === 'number' ? <Hash size={14} /> : <Radar size={14} />}
                      </button>
                      {block.valueType === 'number' ? (
                          <input type="number" className="bg-slate-900 border border-slate-600 rounded w-16 px-2 py-1 text-slate-200 focus:border-blue-500 outline-none"
                            value={block.value} onChange={(e) => updateBlock(block.id, 'value', parseInt(e.target.value))} />
                      ) : (
                          <select className="bg-slate-900 border border-slate-600 rounded px-2 py-1 text-slate-200 focus:border-blue-500 outline-none w-24"
                            value={block.value} onChange={(e) => updateBlock(block.id, 'value', parseInt(e.target.value))}>
                            {Object.entries(SENSOR_LABELS).map(([k, v]) => (<option key={k} value={k}>{v}</option>))}
                          </select>
                      )}
                      <span className="font-bold text-blue-300">→</span>
                      <select className={`border border-slate-600 rounded px-2 py-1 font-bold outline-none flex-grow
                            ${block.action === 'LEFT' || block.action === 'RIGHT' ? 'bg-indigo-900 text-indigo-200' : ''}
                            ${block.action === 'ACCEL' ? 'bg-green-900 text-green-200' : ''}
                            ${block.action === 'BRAKE' ? 'bg-red-900 text-red-200' : ''}`}
                        value={block.action} onChange={(e) => updateBlock(block.id, 'action', e.target.value)}>
                        <option value="LEFT">좌회전</option>
                        <option value="RIGHT">우회전</option>
                        <option value="ACCEL">가속</option>
                        <option value="BRAKE">감속</option>
                      </select>
                      <button onClick={() => removeBlock(block.id)} className="text-slate-500 hover:text-red-400 ml-auto opacity-0 group-hover:opacity-100 transition"><Trash2 size={16} /></button>
                    </div>
                  ))}

                  <button onClick={addBlock} className="w-full py-3 border-2 border-dashed border-slate-600 text-slate-400 rounded-lg hover:border-blue-500 hover:text-blue-400 transition flex justify-center items-center gap-2">
                    <Plus size={18} /> 로직 블록 추가
                  </button>
                </div>
              </div>

              {/* --- Main View: Canvas --- */}
              <div className="flex-1 relative bg-neutral-800 flex justify-center items-center p-4 overflow-hidden">
                <canvas ref={canvasRef} width={TRACK_WIDTH} height={TRACK_HEIGHT}
                    className="bg-green-500 rounded-xl shadow-2xl max-w-full max-h-full object-contain cursor-crosshair" />
                
                {/* Top Right State Badge (Moved from Center) */}
                <div className="absolute top-6 right-6 pointer-events-none">
                    <div className="bg-slate-900/80 backdrop-blur px-6 py-2 rounded-full border border-slate-700 shadow-lg flex items-center gap-4">
                        <div className="text-slate-400 text-xs uppercase tracking-widest">상태</div>
                        <div className={`text-xl font-black italic ${gameState === 'running' ? 'text-green-400' : 'text-slate-200'}`}>
                            {gameState === 'idle' && 'READY'}
                            {gameState === 'running' && 'RUN'}
                            {gameState === 'finished' && 'FINISH'}
                        </div>
                    </div>
                </div>

                {/* Bottom Horizontal Dashboard (Moved from Top to Bottom to avoid blocking start line) */}
                <div className="absolute bottom-6 left-0 right-0 flex justify-center gap-4 px-4 pointer-events-none">
                    {/* My Car Stats Strip */}
                    <div className="bg-slate-900/90 backdrop-blur px-6 py-3 rounded-full border border-slate-700 shadow-2xl flex items-center gap-6 text-sm transform transition-all hover:scale-105">
                         <div className="flex items-center gap-2">
                            <Flag size={14} className="text-blue-400"/>
                            <span className="text-slate-400">Laps</span>
                            <span className="font-mono font-bold text-white text-lg">{userStats.laps}/{TOTAL_LAPS}</span>
                         </div>
                         
                         <div className="w-px h-8 bg-slate-700"></div>

                         <div className="flex flex-col items-center">
                            <span className="text-[10px] text-slate-400">현재 랩</span>
                            <span className="font-mono font-bold text-yellow-400">{fmtTime(userStats.currentLapTime)}</span>
                         </div>
                         
                         <div className="flex flex-col items-center">
                            <span className="text-[10px] text-slate-400">이전 랩</span>
                            <span className="font-mono text-slate-300">{fmtTime(userStats.lastLapTime)}</span>
                         </div>

                         <div className="w-px h-8 bg-slate-700"></div>

                         <div className="flex items-center gap-2">
                            <Timer size={14} className="text-green-400"/>
                            <span className="font-mono font-bold text-lg text-green-400">{fmtTime(userStats.totalTime)}</span>
                         </div>
                    </div>

                    {/* Winner Badge */}
                    {gameState === 'finished' && (
                        <div className={`bg-slate-900/90 backdrop-blur px-6 py-3 rounded-full border border-slate-700 shadow-2xl flex items-center gap-2 font-bold animate-bounce ${winner === 'user' ? 'text-yellow-400' : 'text-red-400'}`}>
                            <Trophy size={18} />
                            {winner === 'user' ? '우승!' : '패배!'}
                        </div>
                    )}
                </div>
                
                {/* Simple Lap Counters for AI (Bottom Left, adjusted slightly up) */}
                <div className="absolute bottom-24 left-8 flex gap-4">
                    {cars.current.slice(1).map(c => (
                        <div key={c.id} className="bg-slate-900/80 backdrop-blur p-2 rounded border border-slate-700 flex flex-col items-center min-w-[60px]">
                            <div className="w-3 h-3 rounded-full mb-1" style={{backgroundColor: c.color}}></div>
                            <div className="text-xs text-slate-400">{c.id.toUpperCase()}</div>
                            <div className="font-mono font-bold">{c.laps}/{TOTAL_LAPS}</div>
                        </div>
                    ))}
                </div>

              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
